2026-01-27-화 실습

#004.엔진x영구저장소 

## 실습 1 : 볼륨 연결 안 하면 수정 사항 적용 안되는 것
https://drive.google.com/drive/folders/1o6K1IQ5JQ4u9BdyBfRNINgwZgjVqCJc_
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/06b38f58-1b4a-43f7-abf7-d512e34b64e7" />

## CLI Ref
```
sudo cd /var/lib

#check all volume list
$ docker volume ls

# new volume name
$ docker volume create

$ docker volume inspect

$ docker volume create webdata
webdata
$ docker volume inspect webdata

$ docker volume prune

#Are you sure you want to continue? [y/N]
y
```
## nginx container 기본 실행
```
#1) 이미지 가져오기
#pull from dockerhub
$ docker pull nginx:1.29-alpine
```
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/143f14a0-6aad-4ce6-9167-076dcd8bfa78" />

```
#2) 컨테이너 실행
#컨테이너 식별 이름 web부여: --name web
#컨테이너 백그라운드 실행,터미널 제어권 유지: -d
docker run -d --name web -p 8080:80  nginx:1.29-alpine

#3) 동작 확인
#'bash'로 확인 가능
#호스트의 8080포트를 컨테이너의 80포트로 연결:Port Mapping
$ curl http://localhost:8080 
```
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/0fb35045-b335-42c6-9a0b-72ca9912a769" />

#### TST(Troubleshooting Tip)
if you can not run the container check you logs
`$ docker logs -f web`

##볼륨으로 HTML콘텐츠 마운트: 볼륨을 html에 붙여야 영구적으로 수정이 반영 됨

```
#1) docker볼륨 생성:데이터 영구저장 볼륨 'webdata(이름)'생성
$ docker volume create webdata

#2) 볼륨 마운트 및 실행:생성한 볼륨을 컨테이너 웹 문서 경로()
#기존 컨테이너 제거(없으면 생략가능)
$ docker rm -f web

$ docker run -d --name web -p 8080:80 \
-v webdata:/usr/share/nginx/html \
nginx:1.29-alpine

#3) 연결 상태 확인
$ docker exec web ls -l /usr/share/nginx/html
$ curl http://localhost:8080
```
#### 2)더 명시적 방법:--mount (권장)
-v옵션: 간편 , --mount: 명확,유연
* 도커 서비스 SWARM등에서는 --mount  방식만 지원하기도 함
```
mount
type=volume,source=webdata,target=/usr/share/nginx/htnl \
```

------
### 쿠버네티스 중단:쿠버네티스에게 시키는거라 아무 위치에서나 가능

어제 그냥 퇴근해서 ip 너무 많아짐 => 쿠버네티스 중단해야 함
<`ip a`결과 화면>
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/d8bafa53-ba3c-4b6a-b065-e0188175fce0" />
도커에서 쿠버네티스 설치 시가상 닉 cni을 flannel로 생성 10.244.0.0으로 등록  
(쿠버네티스:10네트워크 사용, 도커:172 사용<- 휘발성이라 서비스 네임으로 대신:db admin@서비스네임)

```
#이름 확인
$ kubectl get nodes

#워커로드가 있을 때 실용중인 경우를 대비해서 스케줄링 막는 것
$ kubectl cordon master01 #(마스터노드네임)

#데몬 죽이기
$ sudo systemctl stop kubelet

#삭제
$ sudo systemctl disable kubelet

$ sudo systemctl stop contanierd
#도커는 쓰고 있어서 멈추면 안됨

#네트워크 담당 데몬 멈추기
$ sudo systemctl stop kube-proxy #앞에서 담당해서 '프록시'
#Failed :올라가지 않아서 stop 명령어 실패
```
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/285e7fd6-fce8-462f-b888-4887e03d924d" />
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/d0172b01-e5f4-49eb-aacd-48382107aae3" />
<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/f7246437-5163-4149-a66a-c4d6a4ea6373" />


#### 쿠버네티스 중단 후 웹서비스 잘 되는지 확인
```
ip a
ls /etc/netplan
cat /etc/netplan/ 50-cloud-init.yaml
sudo cat /etc/netplan/ 50-cloud-init.yaml
```

```
$ docker exec -it web /bin/sh
$ sudo systemctl restart containerd
$ docker exec  -it web /bin/sh

# ls
# cd share/
#ls
# cd nginx/

#ls
# cd vi html
# cat html

#ls

# exit
```

```
#/var/www/html
$ docker volume ls
$ docker rm -f web

#index.html의 디렉토리 그대로 연결
$ docker run -d --name -p 8080:80 \
> -v webdata:/usr/share/nginx/html nginx:1.29-alpine
#error msg:

$ docker rm -f jolly_goodall
$ docker ps -a
$ sudo systemctl start docker
$ sudo systemcctl start kubelet
$ sudo kubectl get node -w /
```
----
점심
----


# containerd 살리고 enable 다시 해보기
구분해야 하는 것 잘 보기

```
#나라 다 다름
#/var/www/html
$ docker run -d --name web -p 8080:80 nginx:1.29-alpine
$ sudo vi index.html
```
#### Trouble Shooting Point
#vmmaster01는 이미지로 설치한 것 : 이미지로 깐 건 컨테이너에 격리되어 있음 따라서 컨테이너 들어가서 고쳐줘야 함:exec (도커가 os의 도움을 받는 거고 얜 아예 독립적으로)
아래부터!
```
-i : interatcive STandDardIn 터미널에서 입력받는 것
-d : 백그라운드 실행
-t : tty terminal
```
```
$ docker exec -it web /bin/shell #web 뒤에 깔 거 들어옴 만든 사람 마다 달라서 설명 읽어야 함
# cd /usr/share/nginx/html
# ls
# vi index.html
# exit
#컨테이너 죽이기:서비스 자체가 죽음 사이트 연결없음 떠야 맞음
# docker rm -f web

#다시 살리기 # 디폴트가 떠야 맞음
$ docker run -d --name web -p 8080:80 nginx:1.29-alpine
```

####다시 연결
```
#master01/usr/share/nginx/html
#끄기
$ docker rm -f web
#webdata있으면 안만듦
ls 
$ docker volume create fileserver

$ docker volume ls

$ docker run -d --name web -p 8080:80
-v fileserver:/usr/share/nginx/html nginx:1.29-alpine #여기 위치 중요
#영어숫자 섞인 한 줄 로그 나옴
```

### 다시 웹 사이트에 표시 될 내용 수정:vm을 건들인거지 컨테이너 들어가야 함
```
#수정 안 먹는 버전
#/html
$ vi index.html
$ sudo vi index.html #웹서버는 바로 적용됨
```

```
#컨테이너 들어가서 수정 먹는 버전
$ docerk exec -it web /bin/sh
# pwd
# cd /usr/share/nginx/html
# ls
# vi index.html
# 웹서버에 표시 될 내용 적용하고 wq!(저장하고 나오기)는 바로 적용 됨
# exit
```

도커 내리기:서비스 내림 : 웹페이지 찾을 수 없음 나옴
```
$ docker rm -f web
```

다시 서비스 붙이기 : 수정한 페이지 나옴 (위에서 html에 볼륨 붙여서 수정했으니까)
```
$ docker run -d --name web -p 8080:80 \
-v wbedata:/usr/share/nginx/html \
nginxL1.29-alpine
```

---------------
---------------

## 실습2 정적 웹사이트 호스팅
```
# 1 설정 파일 추출 및 수정
$ docker rm -f web

# 2 # 볼륨까지 붙이고 readonly 한 거니까 수정하면 안 됨
$ docker run -d --name wbe2 -p 8080:80 \
-v webdata://usr/share/ngninx/html nginx:1.20-alpine


#주의:Dockerfile이나 CMD를 직접 재정의하여 Nginx를 실행할 때는 반드시 포어그라운드 실행 옵션 필요
#=이미지 다운 받고 바로 실행하면 상관없는데, 도커파일로 재정의하면 꼭 포어그라운드 안그럼 백그라운드(반짝 서비스하고 종료 됨)
#db서버는 밑에서 작업해서 안보임 -d 백그라운드에서 작업하라고 했으니까<-웹서버는 보여야함:포어그라운드
#daemon off:데몬은 숨어서 리슨만 한다(메모리는 수확 영역에 있다가 필요한 연산이 있을 때만 올려서 함) : 숨어있는게 daemon의 기본 성질
#웹서버만! daemon on:숨어있지 않을게= 포어그라운드 할게

# 데이터 유지 확인
$ curl http://localhost:8080
#Output: <h1>웹서버에 띄울 내용 예시:Jello~+WebSerever</h1>

#도커 정의보기
$ docker inspect webdata
```
## 요약 및 참고 자료
바인드는 왜 꼭 묶어 둠?

참고 자료에 들어가면 도커에 대해 자세히 나옴

docker안 쓰더라도 dockerhub는 사용함: 이미지가 많아서 + 워낙 오래 서비스 해서

