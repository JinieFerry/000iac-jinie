도커에서의 최소 단위는 컨테이너, 쿠버네티스에서의 최소 단위는 파드   



<img width="592" height="491" alt="image" src="https://github.com/user-attachments/assets/7bd2d885-9fec-4cd1-a6d8-805657b08b1b" />
10.10.10.1: nginx 하나만 올렸을 때는 컨테이너도 한 개  
10.10.10.2: DB서버 연결했을 때
10.10.10.3: 프론트엔드 백엔드
10.10.10.4: 서버를 두개
실제로는 트래픽을 감당하기 힘든데서 씀:서버 하나에 웹 서버 하나 띄우기도 힘들어서 규모가 있는 데서 쿠버네티스 씀=싱글콘을 씀:그래서 일일이 묶어서 쓰기 힘듦, 규모가 작은 데서는 yaml로도 충분함    
api는 여러대 둠 (모든 통신을 담당하니까,api가 죽으면 그 서버는 죽는 것)


## Pod의 개념과 역할

Kubernetes에서 **Pod(파드)**는 생성하고 관리할 수 있는 **배포 가능한 가장 작은 컴퓨팅 단위**입니다. 하나 이상의 컨테이너(Docker 등)를 그룹화한 것으로, Pod 내의 컨테이너들은 네트워크와 스토리지를 공유하며 밀접하게 결합되어 동작합니다.

### 1. Pod의 주요 특징

* **원자적 단위:** Kubernetes는 컨테이너를 개별적으로 관리하지 않고 Pod 단위로 스케줄링하고 관리합니다.=통째로 관리한다: 파드 안에 DB를 늘려줄 생각을 하는 게 아니라 또 하나 만드는 것
* **공유 네트워크 (IP):** Pod 내의 모든 컨테이너는 동일한 네트워크 네임스페이스(=동일 네트워크라고 이해하면 딱 좋음: 묶어왔으면 DB든 프론트든 백엔드든 네임스페이스한테 전달하면 됨)를 공유합니다. 따라서 컨테이너끼리 `localhost`를 통해 통신할 수 있으며, 동일한 포트 번호를 사용할 수 없습니다.
* **공유 스토리지 (Volume):** Pod 설정에 정의된 볼륨을 Pod 내의 모든 컨테이너가 마운트하여 데이터를 공유할 수 있습니다.
* **휘발성 (Ephemeral):** Pod는 영구적인 존재가 아닙니다.:컨테이너 처럼 삭제하면 다 날라감 노드 장애나 스케줄링 정책에 의해 언제든 삭제되고 새로 생성될 수 있으며, 이때 IP 주소는 변경됩니다.

---
<img width="837" height="556" alt="image" src="https://github.com/user-attachments/assets/01fae8e2-3844-4ba9-9ad9-dba7fc4a037d" />



### 2. Pod의 구성 방식

Pod는 크게 두 가지 형태로 구성됩니다.

| 구성 방식 | 설명 | 주요 사용 사례 |
| --- | --- | --- |
| **Single-Container Pod**:노드마다 큐블렛과 프록시가 같이 있음 | 가장 일반적인 형태이며, 하나의 Pod에 하나의 컨테이너만 실행합니다. | 일반적인 웹 서버, API 서버 등 |
| **Multi-Container Pod**:DNS서버인 경우, 내부에서만 py서버일 때(부서마다 여러가지가 있음)| 주 컨테이너를 보조하는 '사이드카(Sidecar)' 컨테이너를 함께 실행합니다. | 로그 수집기(로그만 뽑아서 로그서버에 보내는 것<>로그서버가 아님:트래픽적음.), 프록시 설정, 데이터 동기화 등 |

결제 정보 뿐 아니라 로그 정보도 잘 남겨야 함 그래서 사이드카 컨테이너를 함께 실행함   

> **실전 팁:** 한 Pod에 여러 컨테이너를 넣는 것은 두 컨테이너가 반드시 **동일한 생명주기**를 가져야 하고, 리소스를 강하게 공유해야 할 때만 사용하세요. 단순히 통신이 필요하다면 별개의 Pod로 분리하고 Service를 통해 연결하는 것이 확장성 면에서 유리합니다.

---

### 3. Pod 생명주기 (Lifecycle)

Pod의 상태는 `status.phase` 필드를 통해 확인할 수 있습니다.

1. **Pending:** 잠깐 뜸)빨리 배정해조~ 아직 노드를 할당 못 받은 상태:파드와 노드 구분 할 줄 알아야 함. Pod가 클러스터에 승인되었지만, 하나 이상의 컨테이너가 실행 준비 중인 상태(이미지 다운로드 등).
2. **Running:** Pod가 노드에 할당되었고, 모든 컨테이너가 생성되었으며 적어도 하나 이상의 컨테이너가 실행 중인 상태.
3. **Succeeded:** 잠깐 뜸 Pod)나 빨리 죽여조~ 내의 모든 컨테이너가 성공적으로 종료되었으며 재시작되지 않는 상태 (주로 Job 객체에서 발생).
4. **Failed:** Pod 내의 모든 컨테이너가 종료되었으나, 적어도 하나 이상의 컨테이너가 실패로 종료된 상태.
5. **Unknown:** Pod의 상태를 확인할 수 없는 경우 (주로 노드와의 통신 단절).
 대부분 러닝 페일 언노운이 뜸. pending과 succeded는 잠깐 떴다가 사라짐

---

### 4. YAML 정의 예시 : 이제부터 이거에 적응이 되어야 함 초창기에 쫙 깔 때 엔서블 많이 쓰고 쿠버네티스는 이 형식을 많이 봄

Pod를 생성하기 위한 표준 `pod.yaml` 형식입니다.

```yaml
apiVersion: v1 #정해진 것 아님(v2나오면 바뀜)
kind: Pod
metadata:
  name: my-webapp
  labels:
    app: web
spec:
  containers:
  - name: main-container
    image: nginx:1.25
    ports:
    - containerPort: 80
  - name: sidecar-logger
    image: busybox
    command: ["sh", "-c", "while true; do date; sleep 10; done"]

```

---

### 💡 자주 오해하는 부분

* **"Pod는 고정된 IP를 가진다?"**
아니요. Pod가 재생성되면 IP는 매번 바뀝니다. 이를 해결하기 위해 **Service**라는 객체를 사용하여 고정된 진입점(VIP)을 제공해야 합니다.
* **"직접 Pod를 생성해도 될까?"**
테스트 목적이 아니라면 `kind: Pod`를 직접 생성하는 것은 권장되지 않습니다. 대신 **Deployment**나 **StatefulSet** 같은 컨트롤러를 사용하여 복제본 관리 및 자동 복구(Self-healing) 기능을 활용해야 합니다.

---

요청하신 대로 교재 구성에 맞춰 내용을 정리했습니다.

**Next Step:** Pod의 네트워킹 및 통신 모델 (Service 연결)
