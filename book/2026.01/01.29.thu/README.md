listen이 아니라 WATCH   

프록시는 내부 서버 밖에서 대표

k8s가 안깔린 것은 노드라고 불리지 않음     

서버는 vm을 노드라고 보기 때문에, vm이 몇개인지에 따라 노드라고부름   

같거나 비슷한 일을 하는 다른 노드의 아이피를 알아야 하기 때문에 그것을 k-proxy가 모아둠. 고객들은 k-proxy로 접속하기 때문에 또 서버와 연결해줘야 함  

노드에는 대표하는 큐블렛이 있고, 유저들이 접속하는 접점이 큐브 프록시    

ansible yaml에서는 다 보내기만 하지 어떻게 죽었는지 알 수가 없음 (성공 여부 정도만 나옴): 죽기 직전까지 예측할 수 없음=대비 불가, 카피,데몬,엔진 올리기 정도의 명령 외에는 선언 뿐    

그래서 정보를 계속 보내게 하고 큐블렛이 자기 노드 상태를 api에게 계속 보고 하면, 그 상태를 etcd에게 저장함   

그러면 명령을 내릴 사람 컨트롤 할 사람이 필요함: 죽은 애 있는지, 살릴 애 있는 지 = 변한 것 있어?   

#### Scheduled :보고 있다가 쓸 수 있는 것과 아닌 것을 분류 해 뒀다가 배정함. 하지만 확정하지 않음  
a였으면 좋겠어, 근데 안되면 b도 괜찮아   

우리 yaml 파일도 모두 etcd에 저장되어 있음.    

ai는 연산하는 일을 함: 같은 노드에 다른 회사 노드도 있음. 하드,메모리 인터페이스 등등 많음, ai는 연산만 하면 되면 cpu연산 전용 노드로 아키텍처에 넣으면 됨. 스토리지가 아주 좋은 성능을 가진 것을 넣어야 함: 여기엔 웹 파드 들어오지마 하고 디테일하게 정할 수 있음      
나는 사실 앱서버야~ 앱이 많고, 주문과 장바구니도 많아 그래서 이게 있는 파드에 같이 놔줘: 떨어져 있으면 그만큼 통신망이 또 차지하기 때문에 <> 난 얘랑 같이 있으면 싫어~하는 경우도 있음    

#### IP는 계속 바뀜: 코딩 할 때 아이피를 아예 줘버리면 통신 할 수가 없음     
프론트에 루트 서비스하는 애 아무나 받아: 서비스 네임으로 통신한다

모든 통신은 api가 중개한다.    
모든 환경들을 etcd에 저장한다.(통신 내역 포함 모든 정보를 저장한 db)    
컨트롤 매니저가 컨트롤 함(클라우드 붙었을 때만 써서 c-c-m)   : 바쁘니까 미리 스케줄 잡아둠   
자기와 친구들 네트워크 정보랑 내 상태를 저장하고 알리는 애가 필요해서 네트워크에서는 노드 마다 큐블렛이 하나씩 있다.    
큐블렛은 각 노드 마다 os로 띄움(os의 데몬으로 띄워버림:그래야 빠르기 때문에, 고정된 것이니까)    
