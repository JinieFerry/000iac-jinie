
https://github.com/putto4u/04.PrivateCloudInfra/blob/main/08.%EB%8F%84%EC%BB%A4%20%EC%BB%B4%ED%8F%AC%EC%A6%88/020.%ED%94%8C%EB%9D%BC%EC%8A%A4%ED%81%AC%2BDB%2BSQL.md

## 다중 컨테이너 웹 애플리케이션 구축 실습 (Flask & MySQL)

본 실습은 **Flask 웹 서버**와 **MySQL 데이터베이스**를 연동하는 전형적인 2-Tier 아키텍처를 도커 컴포즈로 구축합니다. 특히 외부 SQL 파일을 활용한 데이터 초기화와 환경 변수를 이용한 보안 설정을 포함한 중급 수준의 프로젝트입니다.

---

### 1. 프로젝트 설명 및 트리 구조

이 프로젝트는 사용자 정의 Flask 이미지와 공식 MySQL 이미지를 조합합니다. `employees.sql` 데이터를 DB 컨테이너 생성 시 자동으로 주입하며, Flask 서버는 이를 쿼리하여 웹 화면에 부서 정보를 출력합니다.

#### 많이 쓰는 명령어
```
#mysql찾기
#root부터 찾는 거 아니면 .을 침 : 이 이하 위치부터 찾아라
#뭘 찾을 지 옵션: 이름을 알면 -name 뒤에 전체이름 혹은 아는데까지하고 *
$ find . -name employees.sql

#시스템에서 자주 쓰는 명령어
#1기가 이상 용량의 파일이 있는가 찾기: 와일드 카드로 많이 씀
#주로 덤프 파일이 10매가 넘음
$ find . -type f  -size +1000M

#빈파일 찾기
$ find . -empty

#로그는 계속 모디파이 되기 때문에 +30으로 찾으면 그건 30일 이상 서비스 안했다는 뜻
#modified 최근 수정된 적 있는 파일들 찾기:트리거로 삼을 때 변조됐나 안됐나 모디파이도 할 수 있음
#7일 이내에 수정된 파일 찾기
$ find . -mtime -7

#파일이름이 대충은 기억나는데 대소문자 헷갈릴 때 있음
#대소문자 상관없이 찾기
#ignore case
$ find . -iname "대소문자 상관없이 생각나는 이름"
```

찾아보자!
트리구조에 생략했지만 db밑에 employees 덤프파일이 통째로 있어야 함
```
$ find . -name empl*
$ find . -name *dump
```

지니결과
```
master@master01:~/sej/silsoup/0128wed/my-db-project$ cd ~
master@master01:~$ find . -iname 'empl*'
./sej/silsoup/0128wed/my-db-project/db/employees.sql
./before0121/db_back/employees_backup.sql
./imsi/dbbackup/employees.sql
./imsi/dbbackup/employees_partitioned.sql
./imsi/dbbackup/employees_partitioned_5.1.sql
./imsi/dbbackup/images/employees.png
./imsi/dbbackup/images/employees.gif
./imsi/dbbackup/images/employees.jpg
```

**프로젝트 트리 구조**

```text
my-db-project/
├── app.py              # Flask 웹 애플리케이션 (DB 연동 로직)
├── requirements.txt    # Python 패키지 의존성 (Flask, PyMySQL)
├── Dockerfile          # Flask 애플리케이션 빌드 정의서
├── compose.yaml        # 전체 서비스 오케스트레이션 설정
└── db/
    └── employees.sql   # 초기 데이터 주입용 SQL 파일
#testdb를 db로 바꾸거나 카피해두면 됨

```
한번에 만들기!
```
mkdir -p ~/sej/silsoup/0128wed/flask-db-sql && cd ~/sej/silsoup/0128wed/flask-db-sql
touch app.py requirements.txt Dockerfile compose.yaml init.sql
```
지니결과
```
master@master01:~/sej/silsoup/0128wed/flask-db-sql$ ls
app.py  compose.yaml  Dockerfile  init.sql  requirements.txt
master@master01:~/sej/silsoup/0128wed/flask-db-sql$ tree
.
├── app.py
├── compose.yaml
├── Dockerfile
├── init.sql
└── requirements.txt

1 directory, 5 files
```
---

### 2. 파일별 상세 내용 및 주석

#### ① Flask 애플리케이션 (`app.py`)

```python
#이번엔 redis 빼고 flask로 돌릴거다
#frome이 더 큰 거 말함
from flask import Flask, render_template_string
#파이썬에서 sql붙게 만든 거
import pymysql
import os

app = Flask(__name__)

# 환경 변수로부터 DB 접속 정보를 가져옵니다.
DB_HOST = os.environ.get('DB_HOST', 'db')
DB_USER = os.environ.get('DB_USER', 'admin')
DB_PASS = os.environ.get('DB_PASSWORD', 'admin123')
DB_NAME = os.environ.get('DB_NAME', 'employees')

def get_db_connection():
    return pymysql.connect(
        host=DB_HOST,
        user=DB_USER,
        password=DB_PASS,
        db=DB_NAME,
        charset='utf8mb4',
        #db에서는 커서를 씀
        cursorclass=pymysql.cursors.DictCursor
    )

@app.route('/')
def index():
    #db정보를 못 가져올 때 예외처리:파이썬에서는try 사용, if처리 해도 됨
    #예외처리 안하면 qa팀에서 화냄 - 유저네임에 길게 넣어서 해킹할 수도 있음
    try:
        #connetion
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # 부서 정보를 가져오는 SQL 쿼리 실행
            sql = "SELECT dept_no, dept_name FROM departments"

            cursor.execute(sql)
            #리저트에 가져온 거 담아줘
            results = cursor.fetchall()
        conn.close()

        # db로 보내야 하니까
        # 결과를 HTML 테이블로 렌더링 : 내가 작성한 프로그램에선 이미지가 잘 보이지만, 다른 프로그램에선 보는 방식이 다름 : 받는 애 방식대로 바꿔줌 html테이블로 랜더링
        html = """
        <h1>부서 목록 (DB Query Result)</h1>
        <table border="1">
            <tr><th>부서번호</th><th>부서명</th></tr>
            {% for row in results %}
            #row가 줄 마다 봄 results가 여러 줄 일 수 있으니까
            <tr><td>{{ row.dept_no }}</td><td>{{ row.dept_name }}</td></tr>
            #jinja2의 형식 {$ 는 제어문, {{}} 는 변수명
            #for는 ~하는 동안 계속 반복하겠다는 뜻
            #row 값이 없으면 end로 나감
            {% endfor %}
        </table>
        """
        #html에 저장한 결과 값을 리저트에 넣어라
        return render_template_string(html, results=results)
    except Exception as e:
        return f"DB 연결 실패: {str(e)}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

```

#### ② 의존성 파일 (`requirements.txt`)

```text
flask
pymysql
cryptography # render_template_string에 필요한 거

```

#### ③ 웹 서버 빌드 정의서 (`Dockerfile`)

```dockerfile
#파이썬에도 웹서버 쬐끄맣게 있음 테스트용(서비스는 플라스크로)
FROM python:3.9-slim

# 작업 디렉토리 설정
WORKDIR /app

# 필요한 패키지 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 소스 코드 복사
COPY . .

# 5000번 포트 노출
EXPOSE 5000

# Flask 앱 실행
CMD ["python", "app.py"]

```
EXPOSE는 ‘문 열어놨다’는 표시
ports는 ‘밖이랑 실제로 연결한다’는 설정

#### ④ 서비스 구성 (`compose.yaml`) 이미지 만들어서 컨테이너 만들거임

```yaml
#서비스가 3개
services:
  web:
    # 중요함
    # 만들어진 이미지를 받았는데 코드를 넣으면 빌드를 해줘야함:쿠버네티스에서 문제가 됨:빌더가 도커였음 #containerd컨테이너디(데몬)을 설치하면 cli명령어 쓸 수 있음: nerd ctl build <전에는 docker build> 이 빌드를 안에 넣냐 밖에 넣냐로 달라짐
    build: .
    ports:
      - "8080:5000"
    environment:
      - DB_HOST=db
      - DB_NAME=employees
      - DB_USER=admin
      - DB_PASSWORD=admin123
    #이거 없이 못 살아~
    depends_on:
      db:
        #웹서버에서는 실행되자마자 db connetion을 시도함
        #순서가 있어~ db에 서비스가 잘 올라온 뒤에 나를 올려라
        condition: service_healthy # DB가 완전히 준비된 후 웹 서버 실행

  #내 업무를 db로 만들어서 편하게 일해라 db는 여러개 만들 수 있음
  db:
    image: mysql:8.0
    restart: always
    environment:
      - MYSQL_DATABASE=employees
      - MYSQL_ROOT_PASSWORD=root_pass
      - MYSQL_USER=admin
      - MYSQL_PASSWORD=admin123
    ports:
      - "3306:3306"
    volumes:
      # 초기 SQL 파일을 컨테이너 내 예약된 경로에 마운트 (자동 주입)
      #스키마(db구조:테이블선언,테이블 안의 컬럼 정의, 데이터타입 정의, 덤프파일을 테이블에 넣어라)부터 덤프파일까지 db를 만듦
      #./db/employees.sql 이게 어딨는지 콜론 찍고 물어보는 거
      #docker-entrypoint-initdb.d 예약된 디렉토리 명이라서 그대로
      - ./db/employees.sql:/docker-entrypoint-initdb.d/employees.sql
      - mysql_data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"] #"-h"는 옵션
      #인터벌 10초마다 테스트
      interval: 10s
      #5초 지나면 타임아웃
      timeout: 5s
      retries: 5
#볼륨에다 명령했을 때 mysql_data가 보여야 함
volumes:
  mysql_data:

```

---

### 3. 상세 설명 및 핵심 동작 원리

1. **DB 자동 데이터 주입**: MySQL 공식 이미지는 `/docker-entrypoint-initdb.d/` 디렉토리에 있는 `.sql` 파일을 컨테이너 최초 생성 시 자동으로 실행합니다.
2. **어드민 계정 생성**: `MYSQL_USER`와 `MYSQL_PASSWORD` 환경 변수를 통해 루트 외에 일반 관리자 계정을 자동으로 생성합니다.
3. **서비스 의존성 (`healthcheck`)**: 단순 `depends_on`은 컨테이너가 '시작'될 때만 체크합니다. `healthcheck`를 결합하면 DB가 쿼리를 받을 수 있는 '완전 준비' 상태가 되었을 때 Flask가 시작되도록 보장합니다.

---

### 4. 상태 확인 (Status Check)

실행 중인 서비스와 리소스의 상태를 점검합니다. (`docker compose up -d` 실행 후)

**① 서비스 상태 확인 (Compose)**

```bash
docker compose ps

```

```text
NAME                IMAGE               STATUS              PORTS
my-db-project-web-1  my-db-project-web   running             0.0.0.0:8080->5000/tcp
my-db-project-db-1   mysql:8.0           running (healthy)   0.0.0.0:3306->3306/tcp

```

**② 이미지 상태 확인 (Image)**

```bash
docker images

```

```text
REPOSITORY           TAG       IMAGE ID       CREATED          SIZE
my-db-project-web    latest    a1b2c3d4e5f6   1 minute ago     150MB
mysql                8.0       f7e6d5c4b3a2   2 days ago       600MB

```

**③ 전체 시스템 상태 요약 (System)**

```bash
docker system df

```

```text
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          2         2         750MB     0B
Containers      2         2         12.5kB    0B
Local Volumes   1         1         150MB     0B

```

---

### 5. 자원 삭제 및 최종 확인

모든 리소스를 제거하고 깨끗한 상태로 되돌립니다.

```bash
# 1. 모든 서비스 중지 및 삭제 (볼륨, 이미지 포함)
docker compose down -v --rmi all

# 2. 삭제 확인 (목록이 비어있어야 함)
docker compose ps
docker images
docker volume ls

```

---

### AWS 비용 및 유료 전환 주의사항

* **Amazon RDS**: 만약 도커 기반 MySQL 대신 RDS를 사용할 경우, **DB 인스턴스 사양**과 **저장 공간(GP3 등)**에 따라 비용이 실시간으로 청구됩니다. 프리티어 종료 후에는 매우 높은 비용이 발생할 수 있습니다.
* **Data Transfer**: 웹 서버(EC2)와 DB(RDS) 간의 통신이 서로 다른 가용 영역(AZ)에서 발생할 경우 **데이터 전송 비용**이 발생합니다.
* **Public IP**: DB 컨테이너 포트를 외부(3306)로 노출한 채 운영하면 보안에 취약할 뿐만 아니라, EC2 퍼블릭 IP와 관련된 소액의 유지비용이 발생할 수 있습니다.

## Next Step: Docker Compose를 활용한 Nginx 리버스 프록시 설정

*요청하신 대로 초기 데이터 주입과 어드민 계정 생성을 포함한 전체 프로젝트 가이드를 작성하였습니다.*

Next Step: 로그 관리 및 분석 방법
