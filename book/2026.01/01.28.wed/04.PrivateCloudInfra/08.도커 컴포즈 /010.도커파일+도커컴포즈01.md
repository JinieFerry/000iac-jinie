https://github.com/putto4u/04.PrivateCloudInfra/blob/main/08.%EB%8F%84%EC%BB%A4%20%EC%BB%B4%ED%8F%AC%EC%A6%88/010.%EB%8F%84%EC%BB%A4%ED%8C%8C%EC%9D%BC%2B%EB%8F%84%EC%BB%A4%EC%BB%B4%ED%8F%AC%EC%A6%8801.md
## 도커 파일 빌드와 컴포즈 통합 실습 (Flask & Redis)

프로젝트를 시작하기 전, 파일들이 위치할 구조를 먼저 파악하는 것이 중요합니다. 아래 트리를 참고하여 환경을 구성해 주세요.

---

### 1. 프로젝트 디렉토리 트리 구조

실습에 필요한 파일 구성은 다음과 같습니다. 모든 파일은 하나의 루트 디렉토리 안에 위치해야 합니다.

```text
my-flask-app/
├── app.py              # Flask 애플리케이션 소스 코드
├── requirements.txt    # Python 패키지 의존성 목록
├── Dockerfile          # 애플리케이션 이미지 빌드 정의서
└── compose.yaml        # 다중 컨테이너 서비스 정의서

```

**터미널에서 구조 생성하기**

```bash
# 1. 프로젝트 디렉토리 생성 및 이동
mkdir my-flask-app && cd my-flask-app

# 2. 필요한 빈 파일들 생성
touch app.py requirements.txt Dockerfile compose.yaml

## 지동) 한번에 여러 빈 파일 생성하기
mkdir -p my-flask-app && cd my-flask-app && touch app.py requirements.txt Dockerfile compose.yaml

```

프론트엔드는 index.html.htp/thp를 먼저 만듬

백엔드는 동적 컨텐츠를 위한 태어나서 가장  먼저 만나는게 다름
html은 브라우저가 보기 위한 코드
---

### 2. 파일별 상세 내용 작성

생성한 파일들에 아래 내용을 각각 복사하여 저장합니다.

#### ① 소스 코드 작성 (`app.py`) #.py는 파이썬 프로그램이라는 뜻
app.py = index.html같은 거
```python
from flask import Flask
#이름 정도는 알아야함 
#개발팀에서 접속해서 설정같은 것만 자기네가 
#접속자 수 많을 떈, radis 깔아 줌
#데이터는 다 디스크에서 가져오는데, redis는 ram으로 저장-응답해서 빠름:세션관리 왠만한 건 다 처리
from redis import Redis #nginx는 정적 컨텐츠에 잘 맞음 프론트에 많이 씀
import os

app = Flask(__name__)
# environment에서 정의할 REDIS_HOST 변수를 읽어옵니다.
redis = Redis(host=os.environ.get('REDIS_HOST', 'redis'), port=6379)
# /를 쳐두면 접속하면 바로 서버로 감 , 결제홈으로 해두면 거기로 감
#다른거 처리 할 때는 msa 마이크로서비스 (검색,장바구니 등등)
@app.route('/')
#함수는 호출 될 때 변수값 받기도 안받기도 함
#definition 정의, 여기서 사용자명 변수 하나 받아두면 출력, 숫자 넣어두면 함수 내에서 연산할 수도 있음
#지금은 아무것도 안받아서 괄호에 아무것도 안적음
def hello():
    #count란 변수를 redis에서 받아옴,redis안에 increment인 듯(증가), 히트 수 결과값을 가져와서 count한테 넘겨줌
    #명확하게 하려고 변수 count
    count = redis.incr('hits')
    # 접속 횟수를 카운트
    #파이썬에서 변수값 치환할 때 {} 씀, 다른 데서는 $많이 씀
    # f는 format, 형식이 있어!: 날짜 포맷할 때 많이 씀
    return f'Jello! 현재까지 접속 횟수는 {count}번입니다.\n'

# 엔트리포인트:시작할 때 명령이 들어있는 파일 : flask의 엔트리 포인트는 app.py
# 내가 실행시켰을 때 = 다른 프로그램이 호출 할 수 없게.
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000) #0.0.0.0은 다 허용한다는 뜻(외부접속을 위해 서비스)flask는 5000을 씀

```

#### ② 의존성 정의 (`requirements.txt`)

```text
flask
redis

```

#### ③ 빌드 정의서 작성 (`Dockerfile`)

```dockerfile
#자기자신을 실행하기 위해 파이썬 플랫폼으로
FROM python:3.9-slim
#app.py를 실행하겠다
WORKDIR /app
COPY . .
#어딨는지 다 써야 함 라이브러리 여러개를 의존성 정의해서 쓴다 ymal 호스트네임 변수처리 한 거랑 비슷한 것
# pip install은 apt 같은건데 파이썬에서만 씀
RUN pip install --no-cache-dir -r requirements.txt
EXPOSE 5000
CMD ["python", "app.py"]

```

#### ④ 서비스 설정 (`compose.yaml`)

```yaml
services:
  web:
    build: .           # 현재 경로(.)의 Dockerfile을 빌드하여 이미지 생성
    ports:
      - "8080:5000"    # 호스트 8080포트를 컨테이너 5000포트에 연결
    environment:
      - REDIS_HOST=redis
    depends_on:
      - redis
  
  redis:
    image: "redis:alpine"
    volumes:
      - redis_data:/data

volumes:
  redis_data:          # 데이터 보존을 위한 명명된 볼륨

```

---

### 3. 실행, 확인 및 삭제 방법

#### [Step 1] 빌드 및 실행 (Build & Run)

```bash
docker compose up -d --build

```

* `--build`: 소스 코드가 수정되었을 때 새롭게 빌드를 수행하도록 강제합니다.
<img width="973" height="1028" alt="image" src="https://github.com/user-attachments/assets/a608dd8f-c6bf-4f07-b2f3-5462ace9eed2" />




#### [Step 2] 상태 및 로그 확인 (Check)

```bash
# 컨테이너 가동 상태 확인
docker compose ps
```
지니 결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker compose ps
NAME                   IMAGE              COMMAND                  SERVICE   CREATED          STATUS          PORTS
my-flask-app-redis-1   redis:alpine       "docker-entrypoint.s…"   redis     19 seconds ago   Up 18 seconds   6379/tcp
my-flask-app-web-1     my-flask-app-web   "python app.py"          web       18 seconds ago   Up 18 seconds   0.0.0.0:8080->5000/tcp, [::]:8080->5000/tcp

```
```
# 웹 서비스의 로그 실시간 모니터링
docker compose logs -f web

```
지니 결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker compose logs -f web
web-1  |  * Serving Flask app 'app'
web-1  |  * Debug mode: off
web-1  | WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
web-1  |  * Running on all addresses (0.0.0.0)
web-1  |  * Running on http://127.0.0.1:5000
web-1  |  * Running on http://172.18.0.3:5000
web-1  | Press CTRL+C to quit
web-1  | 192.168.10.75 - - [28/Jan/2026 01:54:49] "GET / HTTP/1.1" 200 -

```
* 브라우저에서 `http://localhost:8080`에 접속하여 숫자가 올라가는지 확인합니다.

  지니 결과
<img width="940" height="1048" alt="image" src="https://github.com/user-attachments/assets/3565635b-988d-47f4-b522-2d047d70af5e" />

+ 다른 vm으로 접속하면 접속횟수가 올라갈까? Y:redis에서 hit수를 세고 있기 때문에 올라감
<img width="973" height="1028" alt="image" src="https://github.com/user-attachments/assets/2b62e0e0-258e-4649-9ede-fc0af433cb01" />

<img width="940" height="1048" alt="image" src="https://github.com/user-attachments/assets/68067998-a770-4f3b-be73-7c6a896b738d" />


#### [Step 3] 삭제 및 정리 (Clean up)

```bash
# 컨테이너 및 네트워크 삭제
docker compose down
```
지니결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker compose down
[+] down 3/3
 ✔ Container my-flask-app-web-1   Removed                          10.3s
 ✔ Container my-flask-app-redis-1 Removed                          0.2s
 ✔ Network my-flask-app_default   Removed                          0.1s
 ```
```
# 이미지와 볼륨까지 모두 삭제 (완전 초기화 시 사용)
docker compose down -v --rmi all

```

지니 결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker compose down -v --rmi all
[+] down 3/3
 ✔ Image my-flask-app-web:latest  Removed                           0.1s
 ✔ Image redis:alpine             Removed                           0.1s
 ✔ Volume my-flask-app_redis_data Removed              
```


---




#### [Step 2] 리소스 및 상태 점검 (Status Check)

시스템을 삭제하기 전, 현재 도커 엔진에서 관리되고 있는 리소스의 상태를 확인하는 과정입니다.

**① 서비스 상태 확인 (Compose)**
프로젝트 단위로 실행 중인 컨테이너들의 상태를 요약해서 보여줍니다.

```bash
docker compose ps

```

지니결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app/my-flask-app$ docker compose ps
NAME      IMAGE     COMMAND   SERVICE   CREATED   STATUS    PORTS

```
**출력 예시:**

```text
NAME                   IMAGE               COMMAND                  SERVICE             STATUS              PORTS
my-flask-app-web-1     my-flask-app-web    "python app.py"          web                 running             0.0.0.0:8080->5000/tcp
my-flask-app-redis-1    redis:alpine        "docker-entrypoint.s…"   redis               running             6379/tcp

```

**② 컨테이너 상세 상태 확인 (Container)**
개별 컨테이너의 CPU, 메모리 점유율 등 리소스 사용 현황을 확인합니다.

```bash
docker stats --no-stream

```
지니결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker stats --no-stream
CONTAINER ID   NAME          CPU %     MEM USAGE / LIMIT     MEM %     NET I/O         BLOCK I/O         PIDS
70cd99352b76   file-server   0.00%     27.38MiB / 7.552GiB   0.35%     2.31kB / 126B   36.5MB / 32.8kB   9
```

**출력 예시:**

```text
CONTAINER ID        NAME                    CPU %               MEM USAGE / LIMIT     NET I/O
a1b2c3d4e5f6        my-flask-app-web-1      0.05%               25.4MiB / 7.67GiB     1.2kB / 0B
g7h8i9j0k1l2        my-flask-app-redis-1    0.12%               4.2MiB / 7.67GiB      0B / 0B

```

**③ 이미지 리스트 확인 (Image)**
빌드된 이미지와 다운로드된 베이스 이미지 목록을 확인합니다.

```bash
docker images

```
지니결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker images
                                                    i Info →   U  In Use
IMAGE                   ID             DISK USAGE   CONTENT SIZE   EXTRA
ferryjin/my-web-app:v1
                        8adfefe000e5        237MB         62.9MB        
filebrowser/filebrowser:latest
                        2c54423548d0       38.2MB         12.7MB    U   
hello-world:latest      05813aedc15f       25.9kB         9.52kB        
my-web-app:v1           8adfefe000e5        237MB         62.9MB        
nginx:1.29-alpine       b0f7830b6bfa       93.1MB         26.8MB    U  
```
**출력 예시:**

```text
REPOSITORY           TAG       IMAGE ID       CREATED          SIZE
my-flask-app-web     latest    9f8e7d6c5b4a   2 minutes ago    145MB
redis                alpine    3e2d1c0b9a8f   3 days ago       32.4MB
python               3.9-slim  5a4b3c2d1e0f   2 weeks ago      122MB

```

**④ 전체 시스템 상태 요약 (System)**
도커 전체의 디스크 사용량과 리소스 개수를 확인합니다.

```bash
docker system df

```
지니결과
```
master@master01:~/sej/silsoup/0128wed/my-flask-app$ docker system df
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          4         2         540.7MB   303.9MB (56%)
Containers      2         1         94.21kB   90.11kB (95%)
Local Volumes   12        4         328.9kB   262.7kB (79%)
Build Cache     23        0         463.3MB   226.5MB

```
**출력 예시:**

```text
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          3         2         299.4MB   122MB (40%)
Containers      2         2         0B        0B
Local Volumes   1         1         512B      0B

```

---

### 4. 삭제 및 정리 (Clean up)

```bash
# 컨테이너 및 네트워크 삭제
docker compose down

# 이미지와 볼륨까지 모두 삭제 (완전 초기화 시 사용)
docker compose down -v --rmi all

```

---

### AWS 비용 및 유료 전환 주의사항

* **Amazon ECR**: 직접 빌드한 이미지를 ECR에 보관 시 **데이터 저장 용량**에 따라 과금이 발생합니다.
* **EC2 NAT Gateway**: 프라이빗 서브넷에서 빌드 시 패키지 다운로드 과정에서 **데이터 처리 비용**이 발생할 수 있습니다.
* **EBS 볼륨**: 볼륨이 유지되는 동안 인스턴스 중지와 관계없이 **스토리지 비용**이 청구됩니다.

Next Step: Docker Compose 로그 관리 및 분석 방법

출력 결과가 모바일이나 웹 환경에서도 정렬이 깨지지 않도록 코드 박스(`text` 포맷) 내부에 배치하였습니다.

Next Step: 로그 관리 및 분석 방법
