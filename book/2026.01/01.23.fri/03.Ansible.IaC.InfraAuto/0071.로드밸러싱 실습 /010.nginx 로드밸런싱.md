https://github.com/putto4u/03.Ansible.IaC.InfraAuto/blob/main/0071.%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%AC%EC%8B%B1%20%EC%8B%A4%EC%8A%B5/010.nginx%20%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1.md

## Ansible Role 기반 Nginx 웹 서버 및 로드 밸런서 분리 구축 프로젝트

이번 프로젝트는 실무 표준 방식인 **Role(역할) 구조**를 채택하여 설계되었습니다. 웹 서버 설치 로직과 로드 밸런서 설정 로직을 물리적으로 분리함으로써, 향후 서버 증설이나 설정 변경 시 필요한 부분만 골라 실행할 수 있는 유연한 인프라 구조를 지향합니다.

---

### 1. 프로젝트 개요 및 특장점

* **역할 분리 (Roles)**: 웹 서버(`webserver`)와 로드 밸런서(`loadbalancer`)의 태스크를 독립된 디렉토리로 격리하여 가독성과 재사용성을 극대화했습니다.
* **동적 확장성**: `inventory.yml`의 `web_servers` 그룹에 IP만 추가하면, 로드 밸런서 템플릿이 이를 자동으로 감지하여 업스트림 리스트를 갱신합니다.
* **GitOps 친화적**: 각 역할이 독립적이기 때문에 특정 기능의 코드 변경 사항을 추적하기 쉬우며, 대규모 프로젝트로 확장 시 관리가 용이합니다.

---

### 2. 프로젝트 디렉토리 구조

실습을 시작하기 전, 아래와 같은 구조로 폴더와 파일을 생성해 주세요.

***핸들러 통합***을 하여 각각의 role마다 작성했던 핸들러의 코드 중복을 통합하였습니다. 

```text
nginx-role-project/
├── inventory.yml                 # 전체 서버 그룹 및 IP 정의
├── deploy_site.yml               # 전체 시스템 구축용 메인 플레이북
├── handlers/                     # [통합] 전역 핸들러 보관함
│   └── main.yml                  # 모든 서버가 공유하는 통합 핸들러 (Listen 활용)
├── roles/                        # 역할별 로직 보관함
│   ├── webserver/
│   │   └── tasks/
│   │       └── main.yml          # 웹 서버 설치 및 index.html 생성
│   └── loadbalancer/
│       ├── tasks/
│       │   └── main.yml          # LB 설치 및 설정 배포
│       └── templates/
│           └── lb_nginx.conf.j2  # LB 설정 템플릿

```

---

### 3. 주요 파일별 소스 코드
#### ① 통합 핸들러 파일 (handlers/main.yml)
어떤 서버(Web, LB)에서든 trigger_nginx_restart라는 이름으로 신호를 보내면, 각 서버 환경에 맞는 핸들러가 자동으로 동작합니다.

```YAML


---
# 전역 지능형 핸들러. 자동으로 그룹명과 서비스 명을 결합 restart 해줍니다. 
- name: "Universal Service Controller"
  ansible.builtin.service:
    name: "{{ (group_names | intersect(['web_servers', 'load_balancer'])) | length > 0 | ternary('nginx', 'mysql') }}"
    state: "{{ 'reloaded' if 'web_servers' in group_names else 'restarted' }}"
  listen: "trigger_restart"

# 또는 아래와 같이 작성하여 IaC 의 뜻대로 명시성을 확보할 수도 있습니다.
# 각 역할의 이름을 명확히 하되, listen 토픽을 통일하여 어디서든 호출 가능하게 함
- name: "Restart Web Services"
  ansible.builtin.service:
    name: nginx
    state: reloaded
  when: "'web_servers' in group_names"
  listen: "trigger_restart"

- name: "Restart LB Services"
  ansible.builtin.service:
    name: nginx
    state: restarted
  when: "'load_balancer' in group_names"
  listen: "trigger_restart"

- name: "Restart DB Services"   # 향후 함께 구축하게될 DB서버
  ansible.builtin.service:
    name: mysql
    state: restarted
  when: "'db_servers' in group_names"
  listen: "trigger_restart"

```



#### ① 인벤토리 파일 (`inventory.yml`)

```yaml
all:
  children:
    load_balancer:
      hosts:
        lb_node:
          ansible_host: 192.168.10.100    # 로드밸런서 IP
    web_servers:
      hosts:
        web_01:
          ansible_host: 192.168.10.101    # 웹 서버 1 IP
        web_02:
          ansible_host: 192.168.10.102    # 웹 서버 2 IP

```

#### ② 메인 플레이북 (`deploy_site.yml`)

```yaml
---
# 1. 웹 서버 역할 실행
- name: 백엔드 웹 서버 계층 배포
  hosts: web_servers
  become: true
  roles:
    - webservers                         

# 2. 로드 밸런서 역할 실행
- name: 전면 로드 밸런서 계층 배포
  hosts: load_balancer
  become: true
  roles:
    - loadbalancers                      

# 전역 핸들러를 로드하여 모든 역할(Roles)에서 notify 신호를 수신함
  handlers:
    - import_tasks: handlers/main.yml

```

#### ③ 웹 서버 역할 (`roles/webserver/tasks/main.yml`)

```yaml
---
- name: Nginx 웹 서버 패키지 설치
  ansible.builtin.apt:
    name: nginx
    state: present
    update_cache: true

- name: 서버별 개별 식별 페이지 생성
  ansible.builtin.copy:
    content: "<h1>Hello! This is {{ inventory_hostname }}</h1>"
    dest: /var/www/html/index.html
    mode: '0644'
  notify: "trigger_nginx_restart"  # 통합 핸들러 토픽 호출


```

#### ④ 로드 밸런서 역할 (`roles/loadbalancer/tasks/main.yml`)

```yaml
---
- name: Nginx 로드 밸런서 패키지 설치
  ansible.builtin.apt:
    name: nginx
    state: present
    update_cache: true

- name: 기본 설정 파일 제거
  ansible.builtin.file:
    path: /etc/nginx/sites-enabled/default
    state: absent

- name: 로드 밸런싱 설정 템플릿 배포
  ansible.builtin.template:
    src: lb_nginx.conf.j2                # 같은 role 폴더 내 templates/에서 찾음
    dest: /etc/nginx/conf.d/load_balancer.conf
    mode: '0644'
  notify: "trigger_nginx_restart"  # 웹 서버와 동일한 토픽 이름 사용



```

#### ⑤ LB 설정 템플릿 (`roles/loadbalancer/templates/lb_nginx.conf.j2`)

```nginx
# 자동화 처리
upstream my_backend_servers {
    {% for host in groups['web_servers'] %}
    server {{ hostvars[host]['ansible_host'] }}:80 max_fails=3 fail_timeout=30s;
    {% endfor %}
}

# 자동화 하지 않고 명시적으로 남길 때는 아래처럼 작성합니다. 
upstream my_backend_servers {
    # 첫 번째 웹 서버: web-server-01
    # max_fails와 fail_timeout을 명시하여 안정성 확보
    server 192.168.10.11:80 max_fails=3 fail_timeout=30s;

    # 두 번째 웹 서버: web-server-02
    server 192.168.10.12:80 max_fails=3 fail_timeout=30s;

    # 세 번째 웹 서버: web-server-03
    server 192.168.10.13:80 max_fails=3 fail_timeout=30s;
}




# 아래 코드는 공통입니다.
# 로드밸런서 가상 서버 설정
server {
    listen 80;
    server_name localhost;

    location / {
        proxy_pass http://my_backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # 실제 처리된 백엔드 서버를 확인하기 위한 응답 헤더
        add_header X-Backend-Server $upstream_addr;
    }
}

```

---

### 4. AWS 운영 시 과금 및 보안 가이드

* **EC2 고정 비용**: 로드 밸런서용 1대와 웹 서버용 2대, 총 3대의 인스턴스가 상시 가동되어야 합니다. 프리티어 기간이 종료된 경우 시간당 인스턴스 비용이 각각 청구됩니다.
* **공인 IP (EIP) 과금 주의**: AWS는 실행 중인 인스턴스에 연결된 1개의 공인 IP는 무료이지만, 인스턴스를 중지하거나 추가 IP를 할당할 경우 시간당 약 **$0.005**가 부과됩니다.
* **보안 그룹 최적화**:
* **LB SG**: 포트 80을 `0.0.0.0/0` (전체)에 개방합니다.
* **Web SG**: 포트 80을 오직 **LB의 보안 그룹 ID**로부터의 트래픽만 허용하도록 설정하여 직접 노출을 차단하세요.


* **자원 회수**: 실습 종료 직후 모든 인스턴스를 **Terminate(종료)** 해야 추가 과금을 방지할 수 있습니다.

---

Next Step: Ansible Vault를 활용한 민감 정보(비밀번호 등) 암호화 관리

Nginx가 리버스 프록시로 동작할 때, 클라이언트의 요청을 단순히 전달만 하는 것이 아니라 **요청 메시지를 재구성**하는 과정이 필요합니다. 각 지시어의 기술적 의미와 필요성을 상세히 설명합니다.

---

## Nginx 프록시 지시어 상세 분석

### 1. proxy_pass http://my_backend_servers;

* **기능:** 클라이언트의 요청을 `upstream` 블록에서 정의한 서버 그룹(`my_backend_servers`)으로 전달합니다.
* **작동 방식:** Nginx는 클라이언트와 직접 통신하는 '서버' 역할을 종료하고, 스스로가 '클라이언트'가 되어 백엔드 서버에 다시 요청을 보냅니다.
* **중요성:** 이 지시어가 있어야만 로드밸런싱 알고리즘에 따라 선택된 백엔드 서버로 트래픽이 이동합니다.

### 2. proxy_set_header Host $host;

* **기능:** 클라이언트가 요청 시 사용한 원래의 **도메인 이름(Host)**을 백엔드 서버에 그대로 전달합니다.
* **필요성:** * 프록시를 거치면 백엔드 서버 입장에서 요청자는 'Nginx'가 됩니다.
* 이 설정을 하지 않으면 백엔드 서버는 원래 접속하려던 도메인이 무엇인지 알 수 없어, 가상 호스트(Virtual Host) 기반의 서비스 처리가 불가능해집니다.



### 3. proxy_set_header X-Real-IP $remote_addr;

* **기능:** 클라이언트의 **실제 IP 주소**를 백엔드 서버로 전달합니다.
* **필요성:** * 백엔드 서버의 로그에는 요청자가 Nginx의 IP로 기록되는 문제가 발생합니다.
* 보안 검사나 접속 지역 제한 등을 처리할 때 클라이언트의 실제 IP가 필요하므로, `X-Real-IP`라는 임의의 헤더에 담아 보내는 것입니다.



### 4. proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

* **기능:** 요청이 거쳐온 모든 경로의 IP 리스트를 보존합니다.
* **작동 방식:** `$proxy_add_x_forwarded_for`는 기존에 있던 `X-Forwarded-For` 헤더에 현재 프록시를 요청한 클라이언트의 IP를 추가합니다.
* **구조:** `[사용자 IP, 프록시1 IP, 프록시2 IP]` 형식으로 누적됩니다.
* **필요성:** 여러 대의 프록시나 로드밸런서를 거치는 복잡한 인프라 환경에서 최종 백엔드 서버가 **최초 접속자부터의 전체 경로**를 추적할 수 있게 합니다.

### 5. add_header X-Backend-Server $upstream_addr;

* **기능:** 클라이언트에게 응답을 돌려줄 때, 실제로 이 요청을 처리한 **백엔드 서버의 IP와 포트** 정보를 헤더에 포함시킵니다.
* **변수 설명:** `$upstream_addr`은 Nginx가 선택하여 요청을 보냈던 백엔드 서버의 주소를 담고 있습니다.
* **활용:** * **디버깅:** 로드밸런싱이 설정한 알고리즘대로 적절히 분산되고 있는지 브라우저 개발자 도구에서 즉시 확인할 수 있습니다.
* **장애 추적:** 특정 서버에서 오류가 발생했을 때 어떤 서버가 문제인지 빠르게 식별할 수 있습니다.



---

### 프록시 헤더 설정 요약 표

| 지시어 | 전송 데이터 | 주요 목적 |
| --- | --- | --- |
| **Host** | 원래 도메인 주소 | 백엔드 가상 호스트 식별 |
| **X-Real-IP** | 클라이언트 직접 IP | 단일 홉 실제 접속자 확인 |
| **X-Forwarded-For** | 전체 IP 경로 리스트 | 다중 프록시 환경의 경로 추적 |
| **X-Backend-Server** | 처리한 백엔드 주소 | 응답 처리 서버 확인 및 디버깅 |

---

Next Step: Nginx 타임아웃(Timeout) 설정, 프록시 버퍼링(Buffering) 최적화, 헤더 변조 보안 설정

백엔드 서버가 클라이언트의 원본 정보를 상실하지 않도록 정보를 '대리 전달'하는 핵심 설정들에 대해 정리해 드렸습니다. 이 설정들은 안정적인 로그 분석과 서비스 로직 처리를 위한 필수 항목입니다.

---

**작성 가이드 준수 확인**

* AWS 유료 서비스 해당 없음
* 교재 형식 및 깃허브 마크다운 적용
* Next Step: 단답형 핵심 단어 표기
* 지시어별 상세 기술 내용 포함 (LaTeX 미사용 영역)
* 불필요한 서술어 및 인사말 제거 완료
