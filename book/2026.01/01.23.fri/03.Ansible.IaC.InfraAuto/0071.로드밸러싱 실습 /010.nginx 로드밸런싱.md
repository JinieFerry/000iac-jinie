https://github.com/putto4u/03.Ansible.IaC.InfraAuto/blob/main/0071.%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%AC%EC%8B%B1%20%EC%8B%A4%EC%8A%B5/010.nginx%20%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1.md

###목표: 아이피 넣으면 자기가 알아서 로드발런싱 하게

## Ansible Role 기반 Nginx 웹 서버 및 로드 밸런서 분리 구축 프로젝트

이번 프로젝트는 실무 표준 방식인 **Role(역할) 구조**를 채택하여 설계되었습니다. 웹 서버 설치 로직과 로드 밸런서 설정 로직을 물리적으로 분리함으로써, 향후 서버 증설이나 설정 변경 시 필요한 부분만 골라 실행할 수 있는 유연한 인프라 구조를 지향합니다.

---

### 0. 그대로 복사해서 붙여넣으면 틀리도록 해두었음 힌트: 이름이 중요함 이름이 같아야 해

### 1. 프로젝트 개요 및 특장점

로드 밸런싱이 있기 전에는 
* **역할 분리 (Roles)**: 웹 서버(`webserver`)와 로드 밸런서(`loadbalancer`)의 태스크를 독립된 디렉토리로 격리하여 가독성과 재사용성을 극대화했습니다.
* **동적 확장성**: `inventory.yml`의 `web_servers` 그룹에 IP만 추가하면(몇 대 할지 정해두고 로드밸런싱을 하는 게 아니라 IP만 추가하면 로드 밸런싱 될 수 있게), 로드 밸런서 템플릿이 이를 자동으로 감지하여 업스트림 리스트를 갱신합니다.(실제 웹서버, 실제 DB서버 같은 것이 업스트림)="내가 로드 발런싱 할 IP가 추가 됐네~"
* **GitOps 친화적**: 각 역할이 독립적이기 때문에 특정 기능의 코드 변경 사항을 추적하기 쉬우며, 대규모 프로젝트로 확장 시 관리가 용이합니다. 

MSA=마이크로 서ꈰ스: 잘게 서비스를 쪼개 놓았다
홈-api or whatson or css : 컨텐츠 기반 로드 발랜싱 
---

### 2. 프로젝트 디렉토리 구조

실습을 시작하기 전, 아래와 같은 구조로 폴더와 파일을 생성해 주세요.

***핸들러 통합***을 하여 각각의 role마다 작성했던 핸들러의 코드 중복을 통합하였습니다. 
<= 그간 실습 구조는 hanlders가 너무 많아서 통합시키도록 재명령했음(S2)
 tasks가 따로 묶지 않았다면 tasks랑 handlers가 같이 있었지만,tasks로 묶었기 때문에 templates말고 handlers를 밖에 둠,
 그리고 notify를 handler가 처리했음
 그동안 nginx restarted/ loadbalancer restarted / DBServer restarted 리스타트는 똑같은데 이름이 달라서 따로 만들어야 했음

 그래서 이제 통합 handlers로 따로 뺀 것 : 이제 ~ restarted에서 ~를 변수명으로 받아야 함
 
 
```text
nginx-role-project/
├── inventory.yml                 # 전체 서버 그룹 및 IP 정의
├── deploy_site.yml               # 전체 시스템 구축용 메인 플레이북 #전에는 site하나가 전체 파일을 실행하게 했는데
├── handlers/                     # [통합] 전역 핸들러 보관함
│   └── main.yml                  # 모든 서버가 공유하는 통합 핸들러 (Listen 활용)
├── roles/                        # 역할별 로직 보관함
│   ├── webserver/
│   │   └── tasks/
│   │       └── main.yml          # 웹 서버 설치 및 index.html 생성
│   └── loadbalancer/
│       ├── tasks/
│       │   └── main.yml          # LB 설치 및 설정 배포 
│       └── templates/
│           └── lb_nginx.conf.j2  # LB 설정 템플릿

#하나 더 추가 될 것이고, hostvars가 빠져서 만들어줘야 하는 상태 (아래에서 hostvars사용함)



```

---

### 3. 주요 파일별 소스 코드
#### ① 통합 핸들러 파일 (handlers/main.yml)
어떤 서버(Web, LB)에서든 trigger_nginx_restart라는 이름으로 신호를 보내면, 각 서버 환경에 맞는 핸들러가 자동으로 동작합니다.

```YAML


---
# 전역 지능형 핸들러. 자동으로 그룹명과 서비스 명을 결합 restart 해줍니다.  : 좀 더 프로그래밍 감각
- name: "Universal Service Controller"
  ansible.builtin.service:
    name: "{{ (group_names | intersect(['web_servers', 'load_balancer'])) | length > 0 | ternary('nginx', 'mysql') }}" #intersect에 DB서버도 들어가고 늘어날 것
    state: "{{ 'reloaded' if 'web_servers' in group_names else 'restarted' }}"
  listen: "trigger_restart"

# 또는 아래와 같이 작성하여 IaC 의 뜻대로 명시성을 확보할 수도 있습니다. : 읽기 쉽게
# 각 역할의 이름을 명확히 하되, listen 토픽을 통일하여 어디서든 호출 가능하게 함
- name: "Restart Web Services"
  ansible.builtin.service:
    name: nginx
    state: reloaded
  when: "'web_servers' in group_names" #지금 root방에 있어서 어디 볼 지를 모르니까 어딜 볼 지 알려주는 것 roles에서 웹서버 뜨면 작동해라
  listen: "trigger_restart"

- name: "Restart LB(loadbalancing) Services"
  ansible.builtin.service:
    name: nginx
    state: restarted
  when: "'load_balancer' in group_names"
  listen: "trigger_restart"

- name: "Restart DB Services"   # 향후 함께 구축하게될 DB서버
  ansible.builtin.service:
    name: mysql
    state: restarted
  when: "'db_servers' in group_names"
  listen: "trigger_restart"

```



#### ① 인벤토리 파일 (`inventory.yml`) : 웹서버 두 개를 할 꺼고 하나를 로드밸런서로 쓸 것

```yaml
all:
  children:
    load_balancer:
      hosts:
        lb_node:
          ansible_host: 192.168.10.100    # 로드밸런서 IP
    web_servers:
      hosts:
        web_01:
          ansible_host: 192.168.10.101    # 웹 서버 1 IP
        web_02:
          ansible_host: 192.168.10.102    # 웹 서버 2 IP

```

#### ② 메인 플레이북 (`deploy_site.yml`) 사이트를 시작하는게 대부분이라 사이트로 이름 지음 (웹서버에서는 인덱스)

```yaml
---
# 1. 웹 서버 역할 실행 인벤토리 불러주구
- name: 백엔드 웹 서버 계층 배포
  hosts: web_servers #webserver
  become: true
  roles:
    - webservers                         

# 2. 로드 밸런서 역할 실행 롤스 불러오고
- name: 전면 로드 밸런서 계층 배포
  hosts: load_balancer # 인벤토리명이랑 일치해야 함
  become: true
  roles:
    - loadbalancers    # 디렉토리 명이랑 일치해야 함                    

# 전역 핸들러를 로드하여 모든 역할(Roles)에서 notify 신호를 수신함 핸들러는 이렇게 따로 불러야 함 (yml파일로 따로 묶어놔서)
  handlers:
    - import_tasks: handlers/main.yml #import는 아예 통째로 다 #include는 프로그램 중간 중간에 껴넣을 수 있는 것

```

#### ③ 웹 서버 역할 (`roles/webserver/tasks/main.yml`)

```yaml
---
- name: Nginx 웹 서버 패키지 설치
  ansible.builtin.apt:
    name: nginx
    state: present
    update_cache: true

- name: 서버별 개별 식별 페이지 생성
  ansible.builtin.copy:
    content: "<h1>Hello! This is {{ inventory_hostname }}</h1>" #호스트네임에 자기 번호 매겨서 아예 짓기 {{변수}}어디서 불렀지? 따로 지정해줘야 하는지 생각해보세요
    dest: /var/www/html/index.html
    mode: '0644'
  notify: "trigger_nginx_restart"  # 통합 핸들러 토픽 호출 #이름이 같아야 함 에러 날 것


```

#### ④ 로드 밸런서 역할 (`roles/loadbalancer/tasks/main.yml`)

```yaml
---
- name: Nginx 로드 밸런서 패키지 설치 #엔진엑스 서버가 로드발란서 역할을 할 것
  ansible.builtin.apt:
    name: nginx
    state: present
    update_cache: true

- name: 기본 설정 파일 제거
  ansible.builtin.file:
    path: /etc/nginx/sites-enabled/default  #sites-aviable 밑에 file로 link/
    state: absent #부재하게 해라 보통 도메인을 주는 자리에 nginx를 깔면 default가 나 옴 = 그 서비스 안 할거야 난 로드밸런싱 역할 할거야 그러니까 absent부재 해

- name: 로드 밸런싱 설정 템플릿 배포 #로드 발란싱은 설정파일(jinja2가 만들어 둠)이 필요함
  ansible.builtin.template:
    src: lb_nginx.conf.j2                # 같은 role 폴더 내 templates/에서 찾음
    dest: /etc/nginx/conf.d/load_balancer.conf
    mode: '0644'
  notify: "trigger_nginx_restart"  # 웹 서버와 동일한 토픽 이름 사용 #에러 날 것 뭐랑 일치 해야 하는 지 잘 보세요



```

#### ⑤ LB 설정 템플릿 (`roles/loadbalancer/templates/lb_nginx.conf.j2`) #모든 데몬 보면 컨프 파일이 있음

```nginx
# 로드발런싱 할 거니까 웹서버가 업스트림 #우린 두대만 정의했는데 개수 맞춰야 함 에러 날 것
# 자동화 처리
upstream my_backend_servers {
    {% for host in groups['web_servers'] %}    #{{}}:변수명, {% %}:제어문 for jinja2
    server {{ hostvars[host]['ansible_host'] }}:80 max_fails=3 fail_timeout=30s;
    {% endfor %}
}

# 자동화 처리 쓸 꺼면 이 아래처럼 작성은 주석처리 해야 함 둘 중 하나만 쓰는 것
# 자동화 하지 않고 명시적으로 남길 때는 아래처럼 작성합니다. 
upstream my_backend_servers {
    # 첫 번째 웹 서버: web-server-01 #위에서 두대 정의한 거랑 안 맞음 ip도 맞는지 확인해야함
    # max_fails와 fail_timeout을 명시하여 안정성 확보
    server 192.168.10.11:80 max_fails=3 fail_timeout=30s;  #max_fails=3:니가 서비스해~하고 데이터를 줬는데, 응답 줘~ 응답을 안주면 죽었는지 살았는지 3번만 체크하겠다 (응답 안 하면 다른 애한테 줄 거임) , 그리고 30초 안에 응답 안 하면 3번까지 안 물어 봄 #외국은 30초 주는데 한국은 더 짧게 조정함 (잠시 서비스 멈춰놓고 넘어가는지 확인가능)

    # 두 번째 웹 서버: web-server-02
    server 192.168.10.12:80 max_fails=3 fail_timeout=30s;

    # 세 번째 웹 서버: web-server-03
    server 192.168.10.13:80 max_fails=3 fail_timeout=30s;
}





# 아래 코드는 공통입니다.
# 로드밸런서 가상 서버 설정
server {
    listen 80; 
    server_name localhost; #nginx 돌릴 때 conf파일에서 썼던 내용들 

    location / {
        proxy_pass http://my_backend_servers; #중간 중개자를 proxy라고 부름 그래서 고객 클라이언트를 프록시로 알기 때문에
        proxy_set_header Host $host;  #사실 나 프록시 아니구 이사람이야~ 로그에 내 이름 말고 그 사람 이름 남겨야해~ 그래서 호스트 주소를 남기고
        proxy_set_header X-Real-IP $remote_addr; #실제 작업은 ip로 하기 때문에 실제 아이피를 남김 그래서 변수명 real ip라고 함
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #그동안 거쳐온 애들한테 다 알려줘야 함 내 아이피 앞에 파이어월 아이피 붙고 마지막에 진짜 헤더를 붙여줘야 하는 것 - 네트웤 개념 그대로
        
        # 실제 처리된 백엔드 서버를 확인하기 위한 응답 헤더
        add_header X-Backend-Server $upstream_addr; # 되돌려 줄 때 응답할 때 이렇게 헤드 붙여서 나한테 줘 그럼 내가 그걸 가지고 보내줄게
    }
}

```
 프록시는 대신 = 뒤에 있는 서버를 대신함 => 결과를 다시 앞으로 줘야 함 네트워크에서 NAT가 PAT를 해야하는데 그 개념을 그대로 가져온 것  

 header라는 단어를 그대로 씀 그래서 프록시들이 헤더(프록시가 대신 하고 있는 진짜 호스트의 진짜 아이피)를 달고 다니는건데, 불법 사이트들은 프록시 서버를 많이 씀(나를 숨기기 위해)<-이 경우에는 헤더를 안 붙임

 호스트 네임  
 아이피  
 컨텐츠도 라우팅 해 줌 (계속 아이피를 붙여줌 거쳐 온 것 들) + 마지막에 진짜 아이피 헤더로 붙여 줌
 
 
---

### 4. AWS 운영 시 과금 및 보안 가이드

* **EC2 고정 비용**: 로드 밸런서용 1대와 웹 서버용 2대, 총 3대의 인스턴스가 상시 가동되어야 합니다. 프리티어 기간이 종료된 경우 시간당 인스턴스 비용이 각각 청구됩니다.
* **공인 IP (EIP) 과금 주의**: AWS는 실행 중인 인스턴스에 연결된 1개의 공인 IP는 무료이지만, 인스턴스를 중지하거나 추가 IP를 할당할 경우 시간당 약 **$0.005**가 부과됩니다.
* **보안 그룹 최적화**:
* **LB SG**: 포트 80을 `0.0.0.0/0` (전체)에 개방합니다.
* **Web SG**: 포트 80을 오직 **LB의 보안 그룹 ID**로부터의 트래픽만 허용하도록 설정하여 직접 노출을 차단하세요.


* **자원 회수**: 실습 종료 직후 모든 인스턴스를 **Terminate(종료)** 해야 추가 과금을 방지할 수 있습니다.

---

Next Step: Ansible Vault를 활용한 민감 정보(비밀번호 등) 암호화 관리

Nginx가 리버스 프록시로 동작할 때, 클라이언트의 요청을 단순히 전달만 하는 것이 아니라 **요청 메시지를 재구성**하는 과정이 필요합니다. 각 지시어의 기술적 의미와 필요성을 상세히 설명합니다.

---

## Nginx 프록시 지시어 상세 분석

### 1. proxy_pass http://my_backend_servers;

* **기능:** 클라이언트의 요청을 `upstream` 블록에서 정의한 서버 그룹(`my_backend_servers`)으로 전달합니다.
* **작동 방식:** Nginx는 클라이언트와 직접 통신하는 '서버' 역할을 종료하고, 스스로가 '클라이언트'가 되어 백엔드 서버에 다시 요청을 보냅니다.
* **중요성:** 이 지시어가 있어야만 로드밸런싱 알고리즘에 따라 선택된 백엔드 서버로 트래픽이 이동합니다.

### 2. proxy_set_header Host $host; 상대방꺼 헤더를 붙임 이거 지동이한테 보내는거야 너 지동이 아니면 다시 되돌려줘~

* **기능:** 클라이언트가 요청 시 사용한 원래의 **도메인 이름(Host)**을 백엔드 서버에 그대로 전달합니다.
* **필요성:** * 프록시를 거치면 백엔드 서버 입장에서 요청자는 'Nginx'가 됩니다.
* 이 설정을 하지 않으면 백엔드 서버는 원래 접속하려던 도메인이 무엇인지 알 수 없어, 가상 호스트(Virtual Host) 기반의 서비스 처리가 불가능해집니다.



### 3. proxy_set_header X-Real-IP $remote_addr;

* **기능:** 클라이언트의 **실제 IP 주소**를 백엔드 서버로 전달합니다.
* **필요성:** * 백엔드 서버의 로그에는 요청자가 Nginx의 IP로 기록되는 문제가 발생합니다.
* 보안 검사나 접속 지역 제한 등을 처리할 때 클라이언트의 실제 IP가 필요하므로, `X-Real-IP`라는 임의의 헤더에 담아 보내는 것입니다.



### 4. proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

* **기능:** 요청이 거쳐온 모든 경로의 IP 리스트를 보존합니다.
* **작동 방식:** `$proxy_add_x_forwarded_for`는 기존에 있던 `X-Forwarded-For` 헤더에 현재 프록시를 요청한 클라이언트의 IP를 추가합니다.
* **구조:** `[사용자 IP, 프록시1 IP, 프록시2 IP]` 형식으로 누적됩니다. #사용자 IP가 제일 뒤에 가야 맞는데 지피티가 잘못 적었음 (리스트는 맨 뒤에 추가하기 때문에)
* **필요성:** 여러 대의 프록시나 로드밸런서를 거치는 복잡한 인프라 환경에서 최종 백엔드 서버가 **최초 접속자부터의 전체 경로**를 추적할 수 있게 합니다.

### 5. add_header X-Backend-Server $upstream_addr;

* **기능:** 클라이언트에게 응답을 돌려줄 때, 실제로 이 요청을 처리한 **백엔드 서버의 IP와 포트** 정보를 헤더에 포함시킵니다.
* **변수 설명:** `$upstream_addr`은 Nginx가 선택하여 요청을 보냈던 백엔드 서버의 주소를 담고 있습니다.
* **활용:** * **디버깅:** 로드밸런싱이 설정한 알고리즘대로 적절히 분산되고 있는지 브라우저 개발자 도구에서 즉시 확인할 수 있습니다.
* **장애 추적:** 특정 서버에서 오류가 발생했을 때 어떤 서버가 문제인지 빠르게 식별할 수 있습니다.



---

### 프록시 헤더 설정 요약 표

| 지시어 | 전송 데이터 | 주요 목적 |
| --- | --- | --- |
| **Host** | 원래 도메인 주소 | 백엔드 가상 호스트 식별 |
| **X-Real-IP** | 클라이언트 직접 IP | 단일 홉 실제 접속자 확인 |
| **X-Forwarded-For** | 전체 IP 경로 리스트 | 다중 프록시 환경의 경로 추적 |
| **X-Backend-Server** | 처리한 백엔드 주소 | 응답 처리 서버 확인 및 디버깅 |

---

Next Step: Nginx 타임아웃(Timeout) 설정, 프록시 버퍼링(Buffering) 최적화, 헤더 변조 보안 설정

백엔드 서버가 클라이언트의 원본 정보를 상실하지 않도록 정보를 '대리 전달'하는 핵심 설정들에 대해 정리해 드렸습니다. 이 설정들은 안정적인 로그 분석과 서비스 로직 처리를 위한 필수 항목입니다.

---

**작성 가이드 준수 확인**

* AWS 유료 서비스 해당 없음
* 교재 형식 및 깃허브 마크다운 적용
* Next Step: 단답형 핵심 단어 표기
* 지시어별 상세 기술 내용 포함 (LaTeX 미사용 영역)
* 불필요한 서술어 및 인사말 제거 완료
